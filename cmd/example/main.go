package main

import (
	"fmt"
	"os"
	"strings"

	"github.com/charmbracelet/lipgloss"
	"github.com/gdamore/tcell/v2"
)

// --- Define the content for each help tab ---
var helpTabsContent = []string{
	"--- Help Tab 1: Basic Controls ---\n\nPress 'h' to see more help topics.\nPress 'q' to quit.\n\nThis is the initial help screen.",
	"--- Help Tab 2: Navigation ---\n\nUse arrow keys to move around (if applicable).\nSome elements might be selectable.",
	"--- Help Tab 3: Advanced Features ---\n\nSpecific commands or shortcuts might be available.\nCheck the documentation for details.",
	"--- Help Tab 4: Contact Info ---\n\nFor further assistance, contact support@example.com.",
}

var numTabs = len(helpTabsContent)

// --- State: Holds the application's dynamic data ---
type State struct {
	ActiveTab int  // Which tab index is currently active
	Quit      bool // Signal to quit the application
}

// --- Lip Gloss Styles ---
var (
	// Define styles for different parts of the UI
	BoxStyle = lipgloss.NewStyle().
			Border(lipgloss.NormalBorder(), true). // Add border around the content
			Padding(1, 2).                         // Add padding inside the border
			Width(60).                             // Set a fixed width for the content box (adjust as needed)
			Align(lipgloss.Left)                   // Align text left within the box

	HeaderStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("#0077cc")). // A nice blue color
			PaddingBottom(1).
			Align(lipgloss.Center) // Center the header text

	FooterStyle = lipgloss.NewStyle().
			Faint(true). // Make the footer text less prominent
			PaddingTop(1).
			Align(lipgloss.Center) // Center the footer text

	ContainerStyle = lipgloss.NewStyle().
			Padding(1) // Outer padding around the whole UI block
)

// --- Update: Handles input and returns the *new* state ---
// This function is pure: it only depends on the current state and the event.
// It does *not* modify UI elements directly.
func Update(currentState State, event tcell.Event) (newState State, changed bool) {
	// Start with the current state
	newState = currentState
	changed = false // Assume no change unless we make one

	// We only care about key events
	if keyEvent, ok := event.(*tcell.EventKey); ok {
		switch keyEvent.Rune() {
		case 'h':
			// Calculate the index of the next tab, wrapping around
			newState.ActiveTab = (currentState.ActiveTab + 1) % numTabs
			changed = true // State has changed, need to re-render
		case 'q':
			newState.Quit = true
			changed = true // State has changed (we're quitting)
		}
	}

	return newState, changed
}

// --- View/Render: Generates the styled string output based on the state ---
// This function takes the state and returns the *entire* string that should
// be drawn to the screen.
func RenderUI(state State, screen tcell.Screen) string {
	// Ensure index is valid (defensive programming)
	if state.ActiveTab < 0 || state.ActiveTab >= numTabs {
		state.ActiveTab = 0 // Reset if out of bounds
	}

	// Get the content string for the active tab
	contentString := helpTabsContent[state.ActiveTab]

	// Apply styles to the content string
	styledContent := BoxStyle.Render(contentString)

	// Create header and footer strings
	headerString := HeaderStyle.Render("--- Help Documentation ---")
	footerString := FooterStyle.Render(fmt.Sprintf("Tab %d/%d | Press 'h' to switch tabs | Press 'q' to quit", state.ActiveTab+1, numTabs))

	// Vertically join the styled header, content box, and footer
	// This creates a single block of text with the correct layout
	fullUIBlock := lipgloss.JoinVertical(
		lipgloss.Left, // Align items to the left within the join
		headerString,
		styledContent,
		footerString,
	)

	// Get the dimensions of the terminal screen
	screenWidth, screenHeight := screen.Size()

	// Use lipgloss.Place to center the UI block on the screen
	finalOutput := lipgloss.Place(
		screenWidth,     // Target width
		screenHeight,    // Target height
		lipgloss.Center, // Horizontal alignment
		lipgloss.Center, // Vertical alignment
		fullUIBlock,     // The content to place
		// Optional: Add background color to padded area
		// lipgloss.WithWhitespaceChars("."), // For debugging centering
	)

	return finalOutput
}

// Helper function to write a string to the tcell screen
// This function handles writing multi-line strings generated by lipgloss
func writeStringToScreen(screen tcell.Screen, s string) {
	lines := strings.Split(s, "\n")
	for y, line := range lines {
		for x, r := range line {
			// SetContent writes a single character at position (x, y)
			// We don't need to provide specific styles or info here,
			// as lipgloss has already embedded formatting via ANSI escape codes
			// or by structuring the string with spaces/newlines.
			// tcell's default style is usually fine, or you could set a base style.
			// For this simple example, just writing the character is enough
			// as lipgloss provides the visual layout through the string structure.
			screen.SetContent(x, y, r, nil, tcell.StyleDefault)
		}
	}
}

func main() {
	// --- Initialize tcell screen ---
	screen, err := tcell.NewScreen()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create tcell screen: %v\n", err)
		os.Exit(1)
	}
	defer screen.Fini() // Ensure screen is finalized when we exit

	// Initialize tcell
	if err = screen.Init(); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to initialize tcell: %v\n", err)
		os.Exit(1)
	}

	// Optional: Set default style
	screen.SetStyle(tcell.StyleDefault.Background(tcell.ColorReset).Foreground(tcell.ColorReset))

	// --- Initial State ---
	// This is where our libgloss-like state starts
	currentState := State{
		ActiveTab: 0, // Start showing the first tab
		Quit:      false,
	}

	// --- The Core Application Loop ---
	// This loop continuously renders the UI and waits for input
	for {
		// --- Render ---
		// Generate the string output based on the current state
		outputString := RenderUI(currentState, screen)

		// Clear the previous screen content
		screen.Clear()

		// Write the new output string to the tcell screen buffer
		writeStringToScreen(screen, outputString)

		// Show the changes on the terminal
		screen.Show()

		// If the state indicates quitting, break the loop *before* waiting for input
		if currentState.Quit {
			break
		}

		// --- Wait for Input ---
		// PollEvent blocks until a key is pressed or another event occurs
		event := screen.PollEvent()

		// --- Update ---
		// Call the Update function with the current state and the event
		newState, _ := Update(currentState, event)

		// Update the current state variable with the new state
		currentState = newState
	}

	// Screen.Fini() is called automatically by defer here

	fmt.Println("Exiting help.") // Print a final message after quitting
}
